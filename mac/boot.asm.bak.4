    jmp start   ; 这里可以跳过数据段，跳转到start处执行， 也可以把数据放到尾部
; 字符的字面形式，在编译阶段会转成字符编码, \ 是续行符，在编译的时候，编译器会把续行符去掉，把两行合并成一行
; 也可以不用续行符，重新加一个db，定义一行新的数据也是可以的
; 标号是为了以后访问这些数据用的，如果没有标号，在编写程序的时候，就没办法引用这些文本
mytext db 'L', 0x07, 'a', 0x07, 'b', 0x07, 'e', 0x07, 'l', 0x07, ' ', 0x07, 'o', 0x07,\
          'f', 0x07, 'f', 0x07, 's', 0x07, 'e', 0x07,'t', 0x07, ':', 0x07

; start 是为了让开头跳过来执行，因为 mytext处的都是数据，并不能执行
start:
    ; 设置数据段基地址
    ; ds 设置为7c0的原因是：
    ; 汇编语言源程序的编译符合一种假设，即编译后的代码将从某个内存段中偏移地址为0的地方开始加载，
    ; 这样一来如果有一个标号，如mytext, 他在编译时计算的汇编地址，等于程序加载到内存时的段内偏移地址 
    ; 任何使用标号来访问内存的指令，都不会产生问题，因为加载的偏移地址是0，是从段内偏移地址为0的地方开始加载，汇编地址等于程序加载到内存的段内偏移地址
    mov ax, 0x7c0
    mov ds, ax

    ; 设置附加段基地址
    mov ax, 0xb800
    mov es, ax


    ; 数据串的传送指令，数据串的传送指令，用于把一串或者一批数据从内存的一个地方批量传送或者复制到另一个地方，在处理器看来，被处理的数据就是数据串
    ; 对于8086处理器来说，支持两种串传送指令
    ; 数据串的传送可以按字节进行，也可以按字进行
    ; string（串），byte(字节)，word（字）
    ; movsb
    ; movsw 
    ; 现代处理器支持其他双字等

    ; 8086 处理器传送前的准备
    ; DS:SI 原始数据串的段地址：偏移地址
    ; ES：DI 目标位置的段地址：偏移地址 

    ; 设置传送方向，正向是

    cld ; 方向指令清零指令，是一个无操作数指令，与其相反的是置方向标志指令STD,cld指令将标志寄存器的DF标志清零，以指示传送是正方向的，std 指令将DF标志置1，此时传送方向与cld相反，从高地址到低地址
    mov si, mytext
    mov di, 0
    mov cx, (start-mytext) / 2 ; 实际上等于13
    rep movsw ; movsb 和movsw只能执行一次，如果希望处理器自动反复执行，需要加上前缀rep， rep是repeat的缩写，指令前缀rep要求重复执行，重复的次数要由寄存器cx执行，总字节数，除以2 就等于字数，在每次执行movsw之前，处理器要先检查寄存器cx的值，只有在cx不为0的时候才执行，如果cx是0，则不执行movsw，并离开他，往后执行，传送到此结束

    jmp $ ;维持自身跳转，维持无限循环，相当于以前的jmp again

    times 510 - ($-$$) db 0 ; $ 代表当前这一行的汇编地址 $$ 表示当前程序段的汇编地址，在这里是0
    db 0x55, 0xaa ;添加主引导扇区有效标志 
    


